(in-package :timer-wheel-tests)


(defparameter *test-wheel* (tw::make-wheel :size 10 :resolution 10 :name "TEST-WHEEL"))

(defun make-callback ()
  (lambda (wheel timer)
    (format t "Wheel: ~d, Timer: ~d, Now: ~d~%" (tw::name wheel) (tw::name timer) (local-time:now))
    (if (tw::result timer)
        (incf (slot-value timer 'tw::result))
        (setf (slot-value timer 'tw::result) 1))
    t))

(defun restore-timer-repeats (timer &optional (num 1))
  (incf (slot-value timer 'tw::repeats) num)
  timer)

(defun n-seconds-later (time &optional (n 1))
  "N seconds later after the specified time, return a local-time:timestamp object."
  (let ((ut (cond ((typep time 'local-time:timestamp) (tw::timestamp->universal-milliseconds time))
                  ((typep time 'string) (tw::timestring->universal-milliseconds time))
                  (t (error "Wrong time type: ~d" time)))))
    (tw::universal-milliseconds->timestamp (+ ut (truncate (* n 1000))))))

(defun 1/100-second-before ()
  (n-seconds-later (local-time:now) -0.01))

(defun 1/100-second-after ()
  (n-seconds-later (local-time:now) 0.01))

(define-test make-wheel :parent timer-wheel
  (finish (tw::make-wheel))
  (finish (tw::make-wheel :size 11))
  (finish (tw::make-wheel :resolution 12))
  (finish (tw::make-wheel :name "xxxx"))
  (finish (tw::make-wheel :size 13 :resolution 14))
  (finish (tw::make-wheel :size 15 :name "xx"))
  (finish (tw::make-wheel :resolution 16 :name "xx"))
  (finish (tw::make-wheel :size 17 :resolution 18 :name "aaaa")))

(define-test inspect-wheel :parent timer-wheel
  (let ((tw1 (tw::make-wheel))
        (tw2 (tw::make-wheel :size 11))
        (tw3 (tw::make-wheel :resolution 12))
        (tw4 (tw::make-wheel :name "xxxx"))
        (tw5 (tw::make-wheel :size 13 :resolution 14))
        (tw6 (tw::make-wheel :size 15 :name "xx"))
        (tw7 (tw::make-wheel :resolution 16 :name "xx"))
        (tw8 (tw::make-wheel :size 17 :resolution 18 :name "aaaa")))
    (finish (tw::inspect-wheel tw1))
    (finish (tw::inspect-wheel tw2))
    (finish (tw::inspect-wheel tw3))
    (finish (tw::inspect-wheel tw4))
    (finish (tw::inspect-wheel tw5))
    (finish (tw::inspect-wheel tw6))
    (finish (tw::inspect-wheel tw7))
    (finish (tw::inspect-wheel tw8))))

(define-test make-timer-basic :parent timer-wheel
  (finish (tw::make-timer))
  (finish (tw::make-timer :callback (lambda (tw tm) (declare (ignore tw tm)))))
  (finish (tw::make-timer :scheduler *test-wheel*))
  (finish (tw::make-timer :start-time nil))
  (finish (tw::make-timer :start-time "2022-03-24 16:28:00"))
  (finish (tw::make-timer :start-time "2022-03-24T16:28:00"))
  (finish (tw::make-timer :start-time "2022-03-24T16:28:00-08:00"))
  (finish (tw::make-timer :start-time "2022-03-24T16:28:00.000-08:00"))
  (finish (tw::make-timer :start-time "2022-03-24T16:28:00.000000+08:00"))
  (finish (tw::make-timer :start-time (local-time:now)))
  (finish (tw::make-timer :start-time (tw::timestring->timestamp "2022-03-24 16:28:00")))
  (fail   (tw::make-timer :start-time "2022-03-24 16:28:99"))
  (fail   (tw::make-timer :start-time 123))
  (finish (tw::make-timer :period-in-seconds nil))
  (finish (tw::make-timer :period-in-seconds 0.0001))
  (finish (tw::make-timer :period-in-seconds 0.001))
  (finish (tw::make-timer :period-in-seconds 0.0099))
  (finish (tw::make-timer :period-in-seconds 0.01))
  (finish (tw::make-timer :period-in-seconds 0.1))
  (finish (tw::make-timer :period-in-seconds 1))
  (finish (tw::make-timer :period-in-seconds 2))
  (fail   (tw::make-timer :period-in-seconds 0))
  (fail   (tw::make-timer :period-in-seconds -1))
  (fail   (tw::make-timer :repeat-times -1))
  (fail   (tw::make-timer :repeat-times 0))
  (fail   (tw::make-timer :repeat-times 0.5))
  (finish (tw::make-timer :repeat-times 1))
  (fail   (tw::make-timer :repeat-times 2))
  (finish (tw::make-timer :repeat-times nil))
  (finish (tw::make-timer :end-time nil))
  (finish (tw::make-timer :end-time "2099-03-24 16:28:00"))
  (finish (tw::make-timer :end-time "2099-03-24T16:28:00"))
  (finish (tw::make-timer :end-time "2099-03-24T16:28:00-08:00"))
  (finish (tw::make-timer :end-time "2099-03-24T16:28:00.000-08:00"))
  (finish (tw::make-timer :end-time "2099-03-24T16:28:00.000000+08:00"))
  (finish (tw::make-timer :end-time (1/100-second-after)))
  (fail   (tw::make-timer :end-time (1/100-second-before)))
  (finish (tw::make-timer :end-time (tw::timestring->timestamp "2099-03-24 16:28:00")))
  (fail   (tw::make-timer :end-time "2099-03-24 16:28:99"))
  (fail   (tw::make-timer :end-time 123))
  (finish (tw::make-timer :bindings '((a 1) (b 2))))
  (finish (tw::make-timer :name "xxxx")))

(define-test make-timer-compound :parent timer-wheel
  (let* ((wheel (tw::make-wheel :size 10 :resolution 10 :name "wheel-to-test-make-timer")))
    (finish (tw::make-timer :scheduler wheel :start-time "2022-03-24 16:28:00"))
    (finish (tw::make-timer :scheduler wheel :start-time (local-time:now)))
    (finish (tw::make-timer :scheduler wheel :end-time "2099-03-24 16:28:00"))
    (finish (tw::make-timer :scheduler wheel :period-in-seconds 1))
    (finish (tw::make-timer :scheduler wheel :period-in-seconds 0.1))
    (finish (tw::make-timer :scheduler wheel :period-in-seconds 0.01))
    (fail   (tw::make-timer :scheduler wheel :period-in-seconds 0.0099))
    (fail   (tw::make-timer :scheduler wheel :period-in-seconds 0.001))
    (fail   (tw::make-timer :scheduler wheel :period-in-seconds 0.0001))
    (finish   (tw::make-timer :scheduler wheel :end-time (local-time:now))) ; with default start, start <= end failed
    (finish (tw::make-timer :start-time "2022-03-24 16:28:00" :end-time "2022-03-24 16:28:00"))
    (finish (tw::make-timer :start-time "2022-03-24 16:28:00" :end-time "2022-03-24 16:28:00.000001")) ; 1 us later
    (finish (tw::make-timer :start-time "2022-03-24 16:28:00" :end-time "2022-03-24 16:28:00.001")) ; 1 ms later
    (finish (tw::make-timer :start-time "2022-03-24 16:28:00" :end-time "2022-03-24 16:28:01")) ; 1 second later
    (finish (tw::make-timer :start-time "2022-03-24 16:28:00" :end-time "2022-03-24 16:29:00")) ; 1 minute later
    (finish (tw::make-timer :start-time "2022-03-24 16:28:00" :end-time "2022-03-25 16:28:01")) ; 1 day later
    (finish (tw::make-timer :start-time "2022-03-24 16:28:00" :end-time (local-time:now)))
    (finish (tw::make-timer :start-time "2022-03-24 16:28:00.000001" :end-time "2022-03-24 16:28:00")) ; 1 us before, ignored
    (fail   (tw::make-timer :start-time "2022-03-24 16:28:00.001" :end-time "2022-03-24 16:28:00")) ; 1 ms before
    (fail   (tw::make-timer :start-time "2022-03-24 16:28:01" :end-time "2022-03-24 16:28:00")) ; 1 second before
    (fail   (tw::make-timer :start-time "2022-03-24 16:29:00" :end-time "2022-03-24 16:28:00")) ; 1 minute before
    (fail   (tw::make-timer :start-time "2022-03-25 16:28:00" :end-time "2022-03-24 16:28:00")) ; 1 day before
    (fail   (tw::make-timer :start-time (local-time:now) :end-time "2022-03-25 16:28:01"))
    (finish (tw::make-timer :start-time (local-time:now) :end-time "2099-03-25 16:28:01"))
    (finish (tw::make-timer :start-time (local-time:now) :end-time (local-time:now))) ; start = end most of the time
    (finish (tw::make-timer :start-time nil :end-time nil))
    (finish (tw::make-timer :start-time nil :end-time "2099-03-25 16:28:01"))
    (finish (tw::make-timer :start-time (local-time:now) :end-time nil))
    (finish (tw::make-timer :start-time (local-time:now) :repeat-times 1))
    (fail   (tw::make-timer :start-time (local-time:now) :repeat-times 2))
    (finish (tw::make-timer :start-time (local-time:now) :repeat-times nil)) ; repeat most-positive-fixnum
    (finish (tw::make-timer :start-time "2022-03-25 16:28:00" :repeat-times 1))
    (fail   (tw::make-timer :start-time "2022-03-25 16:28:00" :repeat-times 2))
    (finish (tw::make-timer :start-time "2022-03-25 16:28:00" :repeat-times nil))
    (finish (tw::make-timer :start-time "2022-03-25 16:28:00" :period-in-seconds 0.01))
    (finish (tw::make-timer :start-time "2022-03-25 16:28:00" :period-in-seconds 0.1))
    (finish (tw::make-timer :start-time "2022-03-25 16:28:00" :period-in-seconds 1))
    (finish (tw::make-timer :end-time "2099-03-25 16:28:00" :repeat-times 1))
    (finish (tw::make-timer :end-time "2099-03-25 16:28:00" :repeat-times 2))
    (finish (tw::make-timer :end-time "2099-03-25 16:28:00" :repeat-times nil))
    (finish (tw::make-timer :end-time (n-seconds-later (local-time:now) 0.01) :repeat-times 1))
    (finish (tw::make-timer :end-time (n-seconds-later (local-time:now) 0.01) :repeat-times 2))
    (finish (tw::make-timer :end-time (n-seconds-later (local-time:now) 0.01) :repeat-times nil))
    (finish (tw::make-timer :end-time "2099-03-25 16:28:00" :period-in-seconds 0.01))
    (finish (tw::make-timer :end-time "2099-03-25 16:28:00" :period-in-seconds 0.1))
    (finish (tw::make-timer :end-time "2099-03-25 16:28:00" :period-in-seconds 1))
    (finish (tw::make-timer :end-time (n-seconds-later (local-time:now) 0.01) :period-in-seconds 0.01))
    (finish (tw::make-timer :end-time (n-seconds-later (local-time:now) 0.01) :period-in-seconds 0.1))
    (finish (tw::make-timer :end-time (n-seconds-later (local-time:now) 0.01) :period-in-seconds 1)) ; may fail or finish
    (fail   (tw::make-timer :repeat-times 0 :period-in-seconds 0.01))
    (finish (tw::make-timer :repeat-times 1 :period-in-seconds 0.01))
    (finish (tw::make-timer :repeat-times nil :period-in-seconds 0.01))
    (finish (tw::make-timer :repeat-times 2 :period-in-seconds 0.01))
    (finish (tw::make-timer :repeat-times nil :period-in-seconds 0.01))
    (finish (tw::make-timer :scheduler wheel :start-time "2022-03-25 16:28:00" :end-time "2022-03-25 16:28:00"))
    (finish (tw::make-timer :scheduler wheel :start-time "2022-03-25 16:28:00" :end-time (local-time:now)))
    (fail   (tw::make-timer :scheduler wheel :start-time (local-time:now)      :end-time "2022-03-25 16:28:00"))
    (fail   (tw::make-timer :scheduler wheel :start-time "2022-03-25 16:28:00" :repeat-times 2))
    (fail   (tw::make-timer :scheduler wheel :end-time   "2022-03-25 16:28:00" :repeat-times 2))
    (finish (tw::make-timer :scheduler wheel :start-time "2022-03-25 16:28:00" :period-in-seconds 0.01))
    (finish (tw::make-timer :scheduler wheel :start-time "2022-03-25 16:28:00" :period-in-seconds 0.1))
    (finish (tw::make-timer :scheduler wheel :start-time nil                   :period-in-seconds 0.01))
    (fail   (tw::make-timer :scheduler wheel :start-time nil                   :period-in-seconds 0.005))
    (finish (tw::make-timer :scheduler wheel :start-time "2022-03-25 16:28:00" :period-in-seconds 0.01 :repeat-times 2))
    (finish (tw::make-timer :scheduler wheel :start-time "2022-03-25 16:28:00" :end-time   "2099-03-25 17:28:00"
                            :period-in-seconds 0.01 :repeat-times 2))
    (finish (tw::make-timer :scheduler wheel :start-time "2022-03-25 16:28:00" :end-time "2099-03-25 17:28:00"
                            :period-in-seconds 0.01))
    (finish (tw::make-timer :scheduler wheel :start-time "2022-03-25 16:28:00" :end-time "2099-03-25 17:28:00"
                            :repeat-times 100))
    (finish (tw::make-timer :scheduler wheel :start-time "2022-03-25 16:28:00" :end-time "2022-03-26 16:28:00"
                            :period-in-seconds 0.01 :repeat-times 2))
    ))

;;; the following make-timer-checking-x tests check timer slots with the args provided in make-timer.
;;; one timer instance supplies scheduler and another timer instance does not.

;; none parameters provided
(define-test make-timer-checking-1 :parent timer-wheel
  (let* ((wheel (tw::make-wheel :size 5 :resolution 100 :name "WheelName"))
         (cb (lambda (wheel timer) (format t "Wheel: ~d, Timer: ~d~%" (tw::name wheel) (tw::name timer))))
         (start-time "2022-03-25 16:28:00")
         (end-time   "2022-03-25 16:29:00")
         (start-ms (tw::timestring->universal-milliseconds start-time))
         (end-ms (tw::timestring->universal-milliseconds end-time))
         (now-ms (tw::get-current-universal-milliseconds))
         (timer0 (tw::make-timer :callback cb))
         (timer1 (tw::make-timer :callback cb :scheduler wheel)))
    (is eq :ok (tw::status timer0))
    (is eq :ok (tw::status timer1))
    (is eq nil (tw::scheduled-p timer0))
    (is eq nil (tw::scheduled-p timer1))
    (true (< (abs (- (tw::start timer0) now-ms)) 10))
    (true (< (abs (- (tw::start timer1) now-ms)) 10))
    (is eq nil (tw::end timer0))
    (is eq nil (tw::end timer1))
    (is eq nil (tw::period timer0))
    (is eq nil (tw::period timer1))
    (is = 1 (tw::repeats timer0))
    (is = 1 (tw::repeats timer1))
    (format t "timer0: ~d~%" timer0)
    (format t "timer1: ~d~%" timer1)
    ))

;; start-time
(define-test make-timer-checking-2 :parent timer-wheel
  (let* ((wheel (tw::make-wheel :size 5 :resolution 100 :name "WheelName"))
         (cb (lambda (wheel timer) (format t "Wheel: ~d, Timer: ~d~%" (tw::name wheel) (tw::name timer))))
         (start-time "2022-03-25 16:28:00")
         (end-time   "2022-03-25 16:29:00")
         (start-ms (tw::timestring->universal-milliseconds start-time))
         (end-ms (tw::timestring->universal-milliseconds end-time))
         (now-ms (tw::get-current-universal-milliseconds))
         (timer0 (tw::make-timer :callback cb :start-time start-time))
         (timer1 (tw::make-timer :callback cb :start-time start-time :scheduler wheel)))
    (is eq :ok (tw::status timer0))
    (is eq :ok (tw::status timer1))
    (is eq nil (tw::scheduled-p timer0))
    (is eq nil (tw::scheduled-p timer1))
    (is = 0 (- (tw::start timer0) start-ms))
    (is = 0 (- (tw::start timer1) start-ms))
    (is eq nil (tw::end timer0))
    (is eq nil (tw::end timer1))
    (is eq nil (tw::period timer0))
    (is eq nil (tw::period timer1))
    (is = 1 (tw::repeats timer0))
    (is = 1 (tw::repeats timer1))
    (format t "timer0: ~d~%" timer0)
    (format t "timer1: ~d~%" timer1)
    ))

;; start-time, end-time
(define-test make-timer-checking-3 :parent timer-wheel
  (let* ((wheel (tw::make-wheel :size 5 :resolution 100 :name "WheelName"))
         (cb (lambda (wheel timer) (format t "Wheel: ~d, Timer: ~d~%" (tw::name wheel) (tw::name timer))))
         (start-time "2022-03-25 16:28:00")
         (end-time   "2022-03-25 16:29:00")
         (start-ms (tw::timestring->universal-milliseconds start-time))
         (end-ms (tw::timestring->universal-milliseconds end-time))
         (now-ms (tw::get-current-universal-milliseconds))
         (timer0 (tw::make-timer :callback cb :start-time start-time :end-time end-time))
         (timer1 (tw::make-timer :callback cb :start-time start-time :end-time end-time :scheduler wheel)))
    (is eq :ok (tw::status timer0))
    (is eq :ok (tw::status timer1))
    (is eq nil (tw::scheduled-p timer0))
    (is eq nil (tw::scheduled-p timer1))
    (is = 0 (- (tw::start timer0) start-ms))
    (is = 0 (- (tw::start timer1) start-ms))
    (is = end-ms (tw::end timer0))
    (is = end-ms (tw::end timer1))
    (is eq nil (tw::period timer0))
    (is eq nil (tw::period timer1))
    (is = 1 (tw::repeats timer0))
    (is = 1 (tw::repeats timer1))
    (format t "timer0: ~d~%" timer0)
    (format t "timer1: ~d~%" timer1)
    ))

;; start-time, NO end-time, repeat-times
;; this timer should not be made
(define-test make-timer-checking-4-0 :parent timer-wheel
  (let* ((wheel (tw::make-wheel :size 5 :resolution 100 :name "WheelName"))
         (cb (lambda (wheel timer) (format t "Wheel: ~d, Timer: ~d~%" (tw::name wheel) (tw::name timer))))
         (start-time "2022-03-25 16:28:00")
         (end-time   "2022-03-25 16:29:00")
         (start-ms (tw::timestring->universal-milliseconds start-time))
         (end-ms (tw::timestring->universal-milliseconds end-time))
         (now-ms (tw::get-current-universal-milliseconds))
         (repeat 10))
    (fail (tw::make-timer :callback cb :start-time start-time :repeat-times repeat))
    (fail (tw::make-timer :callback cb :start-time start-time :repeat-times repeat :scheduler wheel))))

;; start-time, end-time, repeat-times
(define-test make-timer-checking-4-1 :parent timer-wheel
  (let* ((wheel (tw::make-wheel :size 5 :resolution 100 :name "WheelName"))
         (cb (lambda (wheel timer) (format t "Wheel: ~d, Timer: ~d~%" (tw::name wheel) (tw::name timer))))
         (start-time "2022-03-25 16:28:00")
         (end-time   "2022-03-25 16:29:00")
         (start-ms (tw::timestring->universal-milliseconds start-time))
         (end-ms (tw::timestring->universal-milliseconds end-time))
         (now-ms (tw::get-current-universal-milliseconds))
         (repeat 10)
         (timer0 (tw::make-timer :callback cb :start-time start-time :end-time end-time :repeat-times repeat))
         (timer1 (tw::make-timer :callback cb :start-time start-time :end-time end-time :repeat-times repeat :scheduler wheel)))
    (is eq :ok (tw::status timer0))
    (is eq :ok (tw::status timer1))
    (is eq nil (tw::scheduled-p timer0))
    (is eq nil (tw::scheduled-p timer1))
    (is = 0 (- (tw::start timer0) start-ms))
    (is = 0 (- (tw::start timer1) start-ms))
    (is = end-ms (tw::end timer0))
    (is = end-ms (tw::end timer1))
    (format t "timer0: ~d~%" timer0)
    (is eq 6000 (tw::period timer0)) ; no schedule, inferred physic milliseconds
    (is eq 60 (tw::period timer1))  ; inferred
    (is = 10 (tw::repeats timer0))
    (is = 10 (tw::repeats timer1))
    (format t "timer0: ~d~%" timer0)
    (format t "timer1: ~d~%" timer1)
    ))

;; start-time, NO end-time, period
(define-test make-timer-checking-5-0 :parent timer-wheel
  (let* ((wheel (tw::make-wheel :size 5 :resolution 100 :name "WheelName"))
         (cb (lambda (wheel timer) (format t "Wheel: ~d, Timer: ~d~%" (tw::name wheel) (tw::name timer))))
         (start-time "2022-03-25 16:28:00")
         (end-time   "2022-03-25 16:29:00")
         (start-ms (tw::timestring->universal-milliseconds start-time))
         (end-ms (tw::timestring->universal-milliseconds end-time))
         (now-ms (tw::get-current-universal-milliseconds))
         (repeat 10)
         (period 0.1)
         (timer0 (tw::make-timer :callback cb :start-time start-time :period-in-seconds period))
         (timer1 (tw::make-timer :callback cb :start-time start-time :period-in-seconds period :scheduler wheel)))
    (is eq :ok (tw::status timer0))
    (is eq :ok (tw::status timer1))
    (is eq nil (tw::scheduled-p timer0))
    (is eq nil (tw::scheduled-p timer1))
    (is = 0 (- (tw::start timer0) start-ms))
    (is = 0 (- (tw::start timer1) start-ms))
    (is eq nil (tw::end timer0))
    (is eq nil (tw::end timer1))
    (is = 100 (tw::period timer0))  ; in milliseconds
    (is eq 1 (tw::period timer1))
    (true (> (tw::repeats timer0) 9999999)) ; inferred
    (true (> (tw::repeats timer1) 9999999)) ; inferred
    (format t "timer0: ~d~%" timer0)
    (format t "timer1: ~d~%" timer1)
    ))

;; start-time, end-time, period
(define-test make-timer-checking-5-1 :parent timer-wheel
  (let* ((wheel (tw::make-wheel :size 5 :resolution 100 :name "WheelName"))
         (cb (lambda (wheel timer) (format t "Wheel: ~d, Timer: ~d~%" (tw::name wheel) (tw::name timer))))
         (start-time "2022-03-25 16:28:00")
         (end-time   "2022-03-25 16:29:00")
         (start-ms (tw::timestring->universal-milliseconds start-time))
         (end-ms (tw::timestring->universal-milliseconds end-time))
         (now-ms (tw::get-current-universal-milliseconds))
         (repeat 10)
         (period 0.1)
         (timer0 (tw::make-timer :callback cb :start-time start-time :end-time end-time :period-in-seconds period))
         (timer1 (tw::make-timer :callback cb :start-time start-time :end-time end-time :period-in-seconds period
                                 :scheduler wheel)))
    (is eq :ok (tw::status timer0))
    (is eq :ok (tw::status timer1))
    (is eq nil (tw::scheduled-p timer0))
    (is eq nil (tw::scheduled-p timer1))
    (is = 0 (- (tw::start timer0) start-ms))
    (is = 0 (- (tw::start timer1) start-ms))
    (is = end-ms (tw::end timer0))
    (is = end-ms (tw::end timer1))
    (is = 100 (tw::period timer0))  ; in milliseconds
    (is eq 1 (tw::period timer1))
    (is = 600 (tw::repeats timer0)) ; inferred
    (is = 600 (tw::repeats timer1)) ; inferred
    (format t "timer0: ~d~%" timer0)
    (format t "timer1: ~d~%" timer1)
    ))

;; start-time, NO end-time, period, repeat
(define-test make-timer-checking-6-0 :parent timer-wheel
  (let* ((wheel (tw::make-wheel :size 5 :resolution 100 :name "WheelName"))
         (cb (lambda (wheel timer) (format t "Wheel: ~d, Timer: ~d~%" (tw::name wheel) (tw::name timer))))
         (start-time "2022-03-25 16:28:00")
         (end-time   "2022-03-25 16:29:00")
         (start-ms (tw::timestring->universal-milliseconds start-time))
         (end-ms (tw::timestring->universal-milliseconds end-time))
         (now-ms (tw::get-current-universal-milliseconds))
         (repeat 10)
         (period 0.1)
         (timer0 (tw::make-timer :callback cb :start-time start-time
                                 :repeat-times repeat :period-in-seconds period))
         (timer1 (tw::make-timer :callback cb :start-time start-time
                                 :repeat-times repeat :period-in-seconds period :scheduler wheel)))
    (is eq :ok (tw::status timer0))
    (is eq :ok (tw::status timer1))
    (is eq nil (tw::scheduled-p timer0))
    (is eq nil (tw::scheduled-p timer1))
    (is = 0 (- (tw::start timer0) start-ms))
    (is = 0 (- (tw::start timer1) start-ms))
    (is eq nil (tw::end timer0))
    (is eq nil (tw::end timer1))
    (is = 100 (tw::period timer0))
    (is eq 1 (tw::period timer1))
    (is = 10 (tw::repeats timer0)) ; use supplied value
    (is = 10 (tw::repeats timer1)) ; use supplied value
    (format t "timer0: ~d~%" timer0)
    (format t "timer1: ~d~%" timer1)
    ))

;; start-time, end-time, period, repeat
(define-test make-timer-checking-6-1 :parent timer-wheel
  (let* ((wheel (tw::make-wheel :size 5 :resolution 100 :name "WheelName"))
         (cb (lambda (wheel timer) (format t "Wheel: ~d, Timer: ~d~%" (tw::name wheel) (tw::name timer))))
         (start-time "2022-03-25 16:28:00")
         (end-time   "2022-03-25 16:29:00")
         (start-ms (tw::timestring->universal-milliseconds start-time))
         (end-ms (tw::timestring->universal-milliseconds end-time))
         (now-ms (tw::get-current-universal-milliseconds))
         (repeat 10)
         (period 0.1)
         (timer0 (tw::make-timer :callback cb :start-time start-time :end-time end-time
                                 :repeat-times repeat :period-in-seconds period))
         (timer1 (tw::make-timer :callback cb :start-time start-time :end-time end-time
                                 :repeat-times repeat :period-in-seconds period :scheduler wheel)))
    (is eq :ok (tw::status timer0))
    (is eq :ok (tw::status timer1))
    (is eq nil (tw::scheduled-p timer0))
    (is eq nil (tw::scheduled-p timer1))
    (is = 0 (- (tw::start timer0) start-ms))
    (is = 0 (- (tw::start timer1) start-ms))
    (is = end-ms (tw::end timer0))
    (is = end-ms (tw::end timer1))
    (is = 100 (tw::period timer0))
    (is eq 1 (tw::period timer1))
    (is = 10 (tw::repeats timer0)) ; use supplied value
    (is = 10 (tw::repeats timer1)) ; use supplied value
    (format t "timer0: ~d~%" timer0)
    (format t "timer1: ~d~%" timer1)
    ))

(define-test inspect-timer :parent timer-wheel
  (finish (tw::inspect-timer (tw::make-timer)))
  (finish (tw::inspect-timer (tw::make-timer :callback (lambda (tw tm) (declare (ignore tw tm))))))
  (finish (tw::inspect-timer (tw::make-timer :scheduler *test-wheel*)))
  (finish (tw::inspect-timer (tw::make-timer :start-time nil)))
  (finish (tw::inspect-timer (tw::make-timer :start-time "2022-03-24 16:28:00")))
  (finish (tw::inspect-timer (tw::make-timer :start-time "2022-03-24T16:28:00")))
  (finish (tw::inspect-timer (tw::make-timer :start-time "2022-03-24T16:28:00-08:00")))
  (finish (tw::inspect-timer (tw::make-timer :start-time "2022-03-24T16:28:00.000-08:00")))
  (finish (tw::inspect-timer (tw::make-timer :start-time "2022-03-24T16:28:00.000000+08:00")))
  (finish (tw::inspect-timer (tw::make-timer :start-time (local-time:now))))
  (finish (tw::inspect-timer (tw::make-timer :start-time (tw::timestring->timestamp "2022-03-24 16:28:00"))))
  (finish (tw::inspect-timer (tw::make-timer :period-in-seconds nil)))
  (finish (tw::inspect-timer (tw::make-timer :period-in-seconds 0.0001)))
  (finish (tw::inspect-timer (tw::make-timer :period-in-seconds 0.001)))
  (finish (tw::inspect-timer (tw::make-timer :period-in-seconds 0.0099)))
  (finish (tw::inspect-timer (tw::make-timer :period-in-seconds 0.01)))
  (finish (tw::inspect-timer (tw::make-timer :period-in-seconds 0.1)))
  (finish (tw::inspect-timer (tw::make-timer :period-in-seconds 1)))
  (finish (tw::inspect-timer (tw::make-timer :period-in-seconds 2)))
  (finish (tw::inspect-timer (tw::make-timer :repeat-times 1)))
  (fail   (tw::inspect-timer (tw::make-timer :repeat-times 2)))
  (finish (tw::inspect-timer (tw::make-timer :repeat-times nil)))
  (finish (tw::inspect-timer (tw::make-timer :end-time nil)))
  (finish (tw::inspect-timer (tw::make-timer :end-time "2099-03-24 16:28:00")))
  (finish (tw::inspect-timer (tw::make-timer :end-time "2099-03-24T16:28:00")))
  (finish (tw::inspect-timer (tw::make-timer :end-time "2099-03-24T16:28:00-08:00")))
  (finish (tw::inspect-timer (tw::make-timer :end-time "2099-03-24T16:28:00.000-08:00")))
  (finish (tw::inspect-timer (tw::make-timer :end-time "2099-03-24T16:28:00.000000+08:00")))
  (finish (tw::inspect-timer (tw::make-timer :end-time (local-time:now))))
  (finish (tw::inspect-timer (tw::make-timer :end-time (tw::timestring->timestamp "2099-03-24 16:28:00"))))
  (finish (tw::inspect-timer (tw::make-timer :bindings '((a 1) (b 2)))))
  (finish (tw::inspect-timer (tw::make-timer :name "xxxx"))))

(define-test attach-scheduler/get-real-period :parent timer-wheel ; may not cover all cases
  (let ((wheel0 (tw::make-wheel :size 10 :resolution 1  :name "wheel-resolution-01"))
        (wheel1 (tw::make-wheel :size 10 :resolution 10 :name "wheel-resolution-10"))
        (wheel2 (tw::make-wheel :size 10 :resolution 20 :name "wheel-resolution-20"))
        (timer0 (tw::make-timer))
        (timer1 (tw::make-timer :period-in-seconds 0.001))
        (timer2 (tw::make-timer :period-in-seconds 0.005))
        (timer3 (tw::make-timer :period-in-seconds 0.01))
        (timer4 (tw::make-timer :period-in-seconds 0.02))
        (timer5 (tw::make-timer :period-in-seconds 0.03))
        (timer6 (tw::make-timer :period-in-seconds 0.1)))
    (is eq nil (tw::period timer0))
    (is = 1   (tw::period timer1))
    (is = 5   (tw::period timer2))
    (is = 10  (tw::period timer3))
    (is = 20  (tw::period timer4))
    (is = 30  (tw::period timer5))
    (is = 100 (tw::period timer6))
    (is eql nil (tw::get-real-period timer0))
    (is = 1   (tw::get-real-period timer1))
    (is = 5   (tw::get-real-period timer2))
    (is = 10  (tw::get-real-period timer3))
    (is = 20  (tw::get-real-period timer4))
    (is = 30  (tw::get-real-period timer5))
    (is = 100 (tw::get-real-period timer6))
    (is eql nil (tw::scheduler timer0))
    (is eql nil (tw::scheduler timer1))
    (is eql nil (tw::scheduler timer2))
    (is eql nil (tw::scheduler timer3))
    (is eql nil (tw::scheduler timer4))
    (is eql nil (tw::scheduler timer5))
    (is eql nil (tw::scheduler timer6))

    (finish (tw::attach-scheduler timer0 wheel1))
    (fail   (tw::attach-scheduler timer1 wheel1))
    (fail   (tw::attach-scheduler timer2 wheel1))
    (finish (tw::attach-scheduler timer3 wheel1))
    (finish (tw::attach-scheduler timer4 wheel1))
    (finish (tw::attach-scheduler timer5 wheel1))
    (finish (tw::attach-scheduler timer6 wheel1))
    (is eq nil (tw::period timer0))
    (is = 1    (tw::period timer1))
    (is = 5    (tw::period timer2))
    (is = 1    (tw::period timer3))
    (is = 2    (tw::period timer4))
    (is = 3    (tw::period timer5))
    (is = 10   (tw::period timer6))
    (is eq wheel1 (tw::scheduler timer0))
    (is eq nil    (tw::scheduler timer1))
    (is eq nil    (tw::scheduler timer2))
    (is eq wheel1 (tw::scheduler timer3))
    (is eq wheel1 (tw::scheduler timer4))
    (is eq wheel1 (tw::scheduler timer5))
    (is eq wheel1 (tw::scheduler timer6))

    (finish (tw::attach-scheduler timer0 wheel2)) ; resulotion 20 ms
    (fail   (tw::attach-scheduler timer1 wheel2))
    (fail   (tw::attach-scheduler timer2 wheel2))
    (fail   (tw::attach-scheduler timer3 wheel2))
    (finish (tw::attach-scheduler timer4 wheel2))
    (fail   (tw::attach-scheduler timer5 wheel2)) ; timer period 0.03s, wheel resolution 0.02s
    (finish (tw::attach-scheduler timer6 wheel2))
    (is eq nil (tw::period timer0))
    (is = 1   (tw::period timer1))
    (is = 5   (tw::period timer2))
    (is = 1  (tw::period timer3))
    (is = 1  (tw::period timer4))
    (is = 3  (tw::period timer5))
    (is = 5  (tw::period timer6))
    (is = 1   (tw::get-real-period timer1))
    (is = 5   (tw::get-real-period timer2))
    (is = 10  (tw::get-real-period timer3))
    (is = 20  (tw::get-real-period timer4))
    (is = 30  (tw::get-real-period timer5))
    (is = 100 (tw::get-real-period timer6))
    (is eq wheel2 (tw::scheduler timer0))
    (is eq nil    (tw::scheduler timer1))
    (is eq nil    (tw::scheduler timer2))
    (is eq wheel1 (tw::scheduler timer3)) ; attach failed, scheduler slot did not change
    (is eq wheel2 (tw::scheduler timer4))
    (is eq wheel1 (tw::scheduler timer5))
    (is eq wheel2 (tw::scheduler timer6))

    (finish (tw::attach-scheduler timer0 wheel0)) ; resoluti 1 ms
    (finish (tw::attach-scheduler timer1 wheel0))
    (finish (tw::attach-scheduler timer2 wheel0))
    (finish (tw::attach-scheduler timer3 wheel0))
    (finish (tw::attach-scheduler timer4 wheel0))
    (finish (tw::attach-scheduler timer5 wheel0))
    (finish (tw::attach-scheduler timer6 wheel0))
    (is = 1   (tw::get-real-period timer1))
    (is = 5   (tw::get-real-period timer2))
    (is = 10  (tw::get-real-period timer3))
    (is = 20  (tw::get-real-period timer4))
    (is = 30  (tw::get-real-period timer5))
    (is = 100 (tw::get-real-period timer6))
    (is eq wheel0 (tw::scheduler timer0))
    (is eq wheel0 (tw::scheduler timer1))
    (is eq wheel0 (tw::scheduler timer2))
    (is eq wheel0 (tw::scheduler timer3))
    (is eq wheel0 (tw::scheduler timer4))
    (is eq wheel0 (tw::scheduler timer5))
    (is eq wheel0 (tw::scheduler timer6))
))

(define-test simple-scheduling :parent timer-wheel ; the original test case of timer-wheel.test
  (setf tw::*tick-num* 0)
  (let* ((wheel (make-wheel :size 100 :resolution 100))
	 (timer (make-timer :callback (lambda (whl tmr)
			                (declare (ignore whl tmr))
                                        (format t "~d Callback result printing!~%" (local-time:now)))
                            :scheduler wheel)))
    (is = 15 (tw::calculate-future-slot 10 5 100))
    (is = 5 (tw::calculate-future-slot 90 15 100))
    (is = 50 (tw::calculate-future-slot 0 150 100))
    ;; Test that there's a minimum of 1 tick when calculating slots
    (is = 11 (tw::calculate-future-slot 10 0 100))
    (tw::schedule-timer wheel timer 1) ; the wheel's thread has just initialized, so the timer was installed in the 10th slot
    (is = 10 (tw::installed-slot timer))
    (is = 0 (remaining timer))
    (is = 1 (tw::queue-count (svref (tw::slots wheel) 10)))
    ;;(is = 1 (length (elt (tw::slots wheel) 10))) ; for the old list queue version
    (format t "Wait for a second to see the result~%......~%")
    (sleep 1)
    (shutdown-timer-wheel wheel)
    ))

;; corresponding to make-timer-checking-1
(define-test scheduler-no-arg :parent timer-wheel
  (let* ((wheel1 (make-wheel :size 10 :resolution 10))
         (wheel2 (make-wheel :size 10 :resolution 20))
         (fn     (make-callback))
         (delay  0.05) ; second
         (timer (make-timer :callback fn)))
    (false (tw::schedule-timer-simply timer))
    (finish (tw::attach-scheduler timer wheel1))
    (is eql wheel1 (tw::scheduler timer))
    (is eql 1 (tw::repeats timer))
    (is eql t (tw::schedule-timer-simply timer))

    (sleep (/ (* 2 (tw::wheel-resolution wheel1)) 1000))
    (is eql 0 (tw::repeats timer))
    (restore-timer-repeats timer)
    (is eql 1 (tw::repeats timer))

    (is eql t (tw:schedule-timer wheel1 timer))
    (is eql wheel1 (tw::scheduler timer))
    (sleep (/ (* 2 (tw::wheel-resolution wheel1)) 1000))
    (restore-timer-repeats timer)

    (is eql t (tw:schedule-timer wheel2 timer))
    (is eql wheel2 (tw::scheduler timer))
    (sleep (/ (* 2 (tw::wheel-resolution wheel2)) 1000))
    (restore-timer-repeats timer)

    (is eql t (tw:schedule-timer wheel1 timer delay))
    (is eql wheel1 (tw::scheduler timer))
    (format t "sleep time: ~d~%" (+ delay (/ (* 2 (tw::wheel-resolution wheel1)) 1000)))
    (sleep (+ delay (/ (* 2 (tw::wheel-resolution wheel1)) 1000)))
    (restore-timer-repeats timer)

    (is eql t (tw:schedule-timer wheel2 timer delay))
    (is eql wheel2 (tw::scheduler timer))
    (sleep (+ delay (/ (* 2 (tw::wheel-resolution wheel2)) 1000)))
    (restore-timer-repeats timer)

    (is eql 1 (tw::repeats timer))
    (is eql 5 (tw::result timer))
))

;; corresponding to make-timer-checking-2
(define-test scheduler-start-time :parent timer-wheel
  (let* ((wheel1 (make-wheel :size 10 :resolution 10))
         (wheel2 (make-wheel :size 10 :resolution 20))
         (fn     (make-callback))
         (delay  0.05) ; second
         (start "2022-03-25 16:28:00")
         (end   "2022-03-25 16:29:00")
         (repeat 10)
         (period 0.1)
         (timer (make-timer :callback fn :start-time start)))
    (false (tw::schedule-timer-simply timer))
    (finish (tw::attach-scheduler timer wheel1))
    (is eql wheel1 (tw::scheduler timer))
    (is eql 1 (tw::repeats timer))
    (is eql t (tw::schedule-timer-simply timer))

    (sleep (/ (* 2 (tw::wheel-resolution wheel1)) 1000))
    (is eql 0 (tw::repeats timer))
    (restore-timer-repeats timer)
    (is eql 1 (tw::repeats timer))

    (is eql t (tw:schedule-timer wheel1 timer))
    (is eql wheel1 (tw::scheduler timer))
    (sleep (/ (* 2 (tw::wheel-resolution wheel1)) 1000))
    (restore-timer-repeats timer)

    (is eql t (tw:schedule-timer wheel2 timer))
    (is eql wheel2 (tw::scheduler timer))
    (sleep (/ (* 2 (tw::wheel-resolution wheel2)) 1000))
    (restore-timer-repeats timer)

    (is eql t (tw:schedule-timer wheel1 timer delay))
    (is eql wheel1 (tw::scheduler timer))
    (format t "sleep time: ~d~%" (+ delay (/ (* 2 (tw::wheel-resolution wheel1)) 1000)))
    (sleep (+ delay (/ (* 2 (tw::wheel-resolution wheel1)) 1000)))
    (restore-timer-repeats timer)

    (is eql t (tw:schedule-timer wheel2 timer delay))
    (is eql wheel2 (tw::scheduler timer))
    (sleep (+ delay (/ (* 2 (tw::wheel-resolution wheel2)) 1000)))
    (restore-timer-repeats timer)

    (is eql 1 (tw::repeats timer))
    (is eql 5 (tw::result timer))
))

;; ;; start-time, end-time, corresponding to make-timer-checking-3
(define-test scheduler-start-time/end-time :parent timer-wheel
  (let* ((wheel1 (make-wheel :size 10 :resolution 10))
         (wheel2 (make-wheel :size 10 :resolution 20))
         (fn     (make-callback))
         (delay  0.05) ; second
         (start "2022-03-25 16:28:00")
         (end   "2099-03-25 16:29:00")
         (repeat 10)
         (period 0.1)
         (just-then (tw::get-current-universal-milliseconds))
         (timer (make-timer :callback fn :start-time start :end-time end)))
    (false (tw::schedule-timer-simply timer))
    (finish (tw::attach-scheduler timer wheel1))
    (is eql wheel1 (tw::scheduler timer))
    (is eql 1 (tw::repeats timer))
    (is eql t (tw::schedule-timer-simply timer))

    (sleep (/ (* 2 (tw::wheel-resolution wheel1)) 1000))
    (is eql 0 (tw::repeats timer))
    (restore-timer-repeats timer)
    (is eql 1 (tw::repeats timer))

    (is eql t (tw:schedule-timer wheel1 timer))
    (is eql wheel1 (tw::scheduler timer))
    (sleep (/ (* 2 (tw::wheel-resolution wheel1)) 1000))
    (restore-timer-repeats timer)

    (is eql t (tw:schedule-timer wheel2 timer))
    (is eql wheel2 (tw::scheduler timer))
    (sleep (/ (* 2 (tw::wheel-resolution wheel2)) 1000))
    (restore-timer-repeats timer)

    (is eql t (tw:schedule-timer wheel1 timer delay))
    (is eql wheel1 (tw::scheduler timer))
    (format t "sleep time: ~d~%" (+ delay (/ (* 2 (tw::wheel-resolution wheel1)) 1000)))
    (sleep (+ delay (/ (* 2 (tw::wheel-resolution wheel1)) 1000)))
    (restore-timer-repeats timer)

    (is eql t (tw:schedule-timer wheel2 timer delay))
    (is eql wheel2 (tw::scheduler timer))
    (sleep (+ delay (/ (* 2 (tw::wheel-resolution wheel2)) 1000)))
    (restore-timer-repeats timer)

    (setf (slot-value timer 'tw::end) just-then)
    (is eql nil (tw:schedule-timer wheel1 timer))

    (is eql 1 (tw::repeats timer))
    (is eql 5 (tw::result timer))
))

;; start-time, end-time, repeat-times, corresponding to make-timer-checking-4-1
(define-test scheduler-start-time/end-time/repeat-times :parent timer-wheel
  (let* ((wheel1 (make-wheel :size 10 :resolution 10))
         (wheel2 (make-wheel :size 10 :resolution 20))
         (fn     (make-callback))
         (delay  0.05) ; second
         (now (local-time:now))
         (start (n-seconds-later now 1))
         (end   (n-seconds-later start 1))
         (repeat 10)
         (period 0.1)
         (just-then (tw::get-current-universal-milliseconds))
         (timer (make-timer :callback fn :start-time start :end-time end :repeat-times repeat)))
    (is = 100 (tw::period timer)) ; scheduler did not specified, can infer physic time in milliseconds
    (false (tw::schedule-timer-simply timer))
    (finish (tw::attach-scheduler timer wheel1))
    (is eql wheel1 (tw::scheduler timer))
    (is eql 10 (tw::repeats timer))
    (is eql t (tw::schedule-timer-simply timer)) ; schedule and run normally

    (sleep (+ 1 (/ (* 2 (tw::wheel-resolution wheel1)) 1000)))
    (format t "timer: ~d~%" timer)
    (is eql 0 (tw::repeats timer))
    (restore-timer-repeats timer repeat)
    (is eql 10 (tw::repeats timer))

    (setf start (n-seconds-later (local-time:now) 1)) ; setf new start and end
    (setf end (n-seconds-later start 1))
    (setf (slot-value timer 'tw::start) (tw::timestamp->universal-milliseconds start)
          (slot-value timer 'tw::end) (tw::timestamp->universal-milliseconds end))

    (is eql t (tw:schedule-timer wheel2 timer)) ; schedule and run normally
    (is eql wheel2 (tw::scheduler timer))
    (is = 5 (tw::period timer))
    (sleep (1+ (/ (* 2 (tw::wheel-resolution wheel2)) 1000)))
    (is eql 0 (tw::repeats timer))
    (restore-timer-repeats timer repeat)

    (is eql t (tw:schedule-timer wheel1 timer delay)) ; schedule but expired
    (is eql wheel1 (tw::scheduler timer))

    (is eql 10 (tw::repeats timer)) ; can be scheduled, but it has already expired, so repeats did not change
    (is eql 20(tw::result timer))
    ))

;; start-time, NO end-time, period, corresponding to make-timer-checking-5-0
(define-test scheduler-start-time/no-end-time/period :parent timer-wheel
  (let* ((wheel1 (make-wheel :size 10 :resolution 10))
         (wheel2 (make-wheel :size 10 :resolution 20))
         (fn     (let ((n 10))
                   (lambda (wheel timer)
                     (declare (ignore wheel))
                     (incf (slot-value timer 'tw::result))
                     (format t "Inf timer scheduling, but will exit when n = 0, now n = ~d~%" n)
                     (if (<= n 2)
                         (setf (slot-value timer 'tw::repeats) 0))
                     (decf n))))
         (delay  0.05) ; second
         (now (local-time:now))
         (start (n-seconds-later now 1))
         (end   (n-seconds-later start 1))
         (repeat 10)
         (period 0.1)
         (just-then (tw::get-current-universal-milliseconds))
         (timer (make-timer :callback fn :start-time start :period-in-seconds period)))
    (format t "timer: ~d~%" timer)
    (setf (slot-value timer 'tw::result) 0)
    (is = 100 (tw::period timer))
    (false (tw::schedule-timer-simply timer))
    (finish (tw::attach-scheduler timer wheel1))
    (is eql wheel1 (tw::scheduler timer))
    (is = 10 (tw::period timer))
    (true (> (tw::repeats timer) 999999999))
    (format t "Scheduling for the 1st time~%")
    (is eql t (tw::schedule-timer-simply timer)) ; schedule and run normally

    (sleep (+ 1 (/ (* 2 (tw::wheel-resolution wheel1)) 1000)))
    (is eql 0 (tw::repeats timer))
    (restore-timer-repeats timer repeat)
    (is eql 10 (tw::repeats timer))
    (is eql 10 (tw::result timer))
    (format t "timer: ~d~%" timer)

    (setf start (n-seconds-later (local-time:now) 1)) ; setf new start and end
    ;;(setf end (n-seconds-later start 1))
    (setf (slot-value timer 'tw::start) (tw::timestamp->universal-milliseconds start))
    ;;      (slot-value timer 'tw::end) (tw::timestamp->universal-milliseconds end))

    (format t "Scheduling for the 2nd time~%")
    (is eql t (tw:schedule-timer wheel2 timer)) ; schedule and run normally
    (is eql wheel2 (tw::scheduler timer))
    (is = 5 (tw::period timer))
    (sleep (1+ (/ (* 2 (tw::wheel-resolution wheel2)) 1000)))
    (is eql 0 (tw::repeats timer))
    (restore-timer-repeats timer repeat)

    (format t "Scheduling for the 3rd time~%")
    (is eql t (tw:schedule-timer wheel1 timer delay)) ; schedule but expired
    (is eql wheel1 (tw::scheduler timer))
    (is eql 10 (tw::repeats timer)) ; can be scheduled, but it has already expired, so repeats did not change

    (sleep (+ 1 (/ (* 2 (tw::wheel-resolution wheel1)) 1000)))
    (is = 14 (tw::result timer)) ; the tick function does not check repeats and thus the last 2 schedulings incf 2 for each
    (format t "timer: ~d~%" timer)
    ))

;; start-time, end-time, period, corresponding to make-timer-checking-5-1
(define-test scheduler-start-time/end-time/period :parent timer-wheel
  (let* ((wheel1 (make-wheel :size 10 :resolution 10))
         (wheel2 (make-wheel :size 10 :resolution 20))
         (fn     (let ((n 10))
                   (lambda (wheel timer)
                     (declare (ignore wheel))
                     (incf (slot-value timer 'tw::result))
                     (format t "Inf timer scheduling, but will exit when n = 0, now n = ~d~%" n)
                     (if (<= n 2)
                         (setf (slot-value timer 'tw::repeats) 0))
                     (decf n))))
         (delay  0.05) ; second
         (now (local-time:now))
         (start (n-seconds-later now 1))
         (end   (n-seconds-later start 1))
         (repeat 10)
         (period 0.1)
         (just-then (tw::get-current-universal-milliseconds))
         (timer (make-timer :callback fn :start-time start :end-time end :period-in-seconds period)))
    (format t "timer: ~d~%" timer)
    (setf (slot-value timer 'tw::result) 0)
    (is = 100 (tw::period timer))
    (false (tw::schedule-timer-simply timer))
    (finish (tw::attach-scheduler timer wheel1))
    (is eql wheel1 (tw::scheduler timer))
    (is = 10 (tw::period timer))
    (is = 10 (tw::repeats timer))
    (format t "Scheduling for the 1st time~%")
    (is eql t (tw::schedule-timer-simply timer)) ; schedule and run normally

    (sleep (+ 1 (/ (* 2 (tw::wheel-resolution wheel1)) 1000)))
    (is eql 0 (tw::repeats timer))
    (restore-timer-repeats timer repeat)
    (is eql 10 (tw::repeats timer))
    (is eql 10 (tw::result timer))
    (format t "timer: ~d~%" timer)

    (setf start (n-seconds-later (local-time:now) 1)) ; setf new start and end
    (setf end (n-seconds-later start 1))
    (setf (slot-value timer 'tw::start) (tw::timestamp->universal-milliseconds start)
          (slot-value timer 'tw::end) (tw::timestamp->universal-milliseconds end))

    (format t "Scheduling for the 2nd time~%")
    (is eql t (tw:schedule-timer wheel2 timer)) ; schedule and run normally
    (is eql wheel2 (tw::scheduler timer))
    (is = 5 (tw::period timer))
    (sleep (1+ (/ (* 2 (tw::wheel-resolution wheel2)) 1000)))
    (is eql 0 (tw::repeats timer))
    (restore-timer-repeats timer repeat)

    (format t "timer: ~d~%" timer)
    ))

;; start-time, NO end-time, period, repeat, corresponding to make-timer-checking-6-0
(define-test scheduler-start-time/no-end-time/period/repeat :parent timer-wheel
  (let* ((wheel1 (make-wheel :size 10 :resolution 10))
         (wheel2 (make-wheel :size 10 :resolution 20))
         (fn     (make-callback))
         (delay  0.05) ; second
         (now (local-time:now))
         (start (n-seconds-later now 1))
         (end   (n-seconds-later start 1))
         (repeat 10)
         (period 0.1)
         (timer (make-timer :callback fn :start-time start :period-in-seconds period :repeat-times repeat)))
    (format t "timer: ~d~%" timer)
    (setf (slot-value timer 'tw::result) 0)
    (is = 100 (tw::period timer))
    (false (tw::schedule-timer-simply timer))
    (finish (tw::attach-scheduler timer wheel1))
    (is eql wheel1 (tw::scheduler timer))
    (is = 10 (tw::period timer))
    (is = repeat (tw::repeats timer))
    (format t "Scheduling for the 1st time~%")
    (is eql t (tw::schedule-timer-simply timer)) ; schedule and run normally

    (sleep (1+ (/ (* 2 (tw::wheel-resolution wheel1)) 1000)))
    (is eql 0 (tw::repeats timer))
    (restore-timer-repeats timer repeat)
    (is eql 10 (tw::repeats timer))
    (is eql 10 (tw::result timer))
    (format t "timer: ~d~%" timer)

    (setf start (n-seconds-later (local-time:now) 1)) ; setf new start and end
    ;;(setf end (n-seconds-later start 1))
    (setf (slot-value timer 'tw::start) (tw::timestamp->universal-milliseconds start))
    ;;      (slot-value timer 'tw::end) (tw::timestamp->universal-milliseconds end))

    (format t "Scheduling for the 2nd time~%")
    (is eql t (tw:schedule-timer wheel2 timer))
    (is eql wheel2 (tw::scheduler timer))
    (is = 5 (tw::period timer))
    (sleep (1+ (/ (* 2 (tw::wheel-resolution wheel2)) 1000)))
    (is eql 0 (tw::repeats timer))
    (restore-timer-repeats timer repeat)

    (format t "Scheduling for the 3rd time~%")
    (is eql t (tw:schedule-timer wheel1 timer delay))
    (is eql wheel1 (tw::scheduler timer))
    (is eql 10 (tw::repeats timer))

    (sleep (+ 1 (/ (* 2 (tw::wheel-resolution wheel1)) 1000)))
    (is = 30 (tw::result timer))
    (format t "timer: ~d~%" timer)
    ))

;; start-time, end-time, period, repeat, corresponding to make-timer-checking-6-1
(define-test scheduler-start-time/end-time/period/repeat :parent timer-wheel
  (let* ((wheel1 (make-wheel :size 10 :resolution 10 :name "wheel1"))
         (wheel2 (make-wheel :size 10 :resolution 20 :name "wheel2"))
         (fn     (make-callback))
         (delay  0.05) ; second
         (now (local-time:now))
         (start (n-seconds-later now 1))
         (end   (n-seconds-later start 1))
         (repeat 10)
         (period 0.1)
         (timer (make-timer :callback fn :start-time start :end-time end :period-in-seconds period :repeat-times repeat)))
    (format t "timer: ~d~%" timer)
    (setf (slot-value timer 'tw::result) 0)
    (is = 100 (tw::period timer))
    (false (tw::schedule-timer-simply timer))
    (finish (tw::attach-scheduler timer wheel1))
    (is eql wheel1 (tw::scheduler timer))
    (is = 10 (tw::period timer))
    (is = repeat (tw::repeats timer))
    (format t "Scheduling for the 1st time~%")
    (is eql t (tw::schedule-timer-simply timer)) ; schedule and run normally

    (sleep (1+ (/ (* 2 (tw::wheel-resolution wheel1)) 1000)))
    (is eql 0 (tw::repeats timer))
    (restore-timer-repeats timer repeat)
    (is eql 10 (tw::repeats timer))
    (is eql 10 (tw::result timer))
    (format t "timer: ~d~%" timer)

    (setf start (n-seconds-later (local-time:now) 1)) ; setf new start and end
    (setf end (n-seconds-later start 1))
    (setf (slot-value timer 'tw::start) (tw::timestamp->universal-milliseconds start)
          (slot-value timer 'tw::end) (tw::timestamp->universal-milliseconds end))

    (format t "Scheduling for the 2nd time~%")
    (is eql t (tw:schedule-timer wheel2 timer))
    (is eql wheel2 (tw::scheduler timer))
    (is = 5 (tw::period timer))
    (sleep (1+ (/ (* 2 (tw::wheel-resolution wheel2)) 1000)))
    (is eql 0 (tw::repeats timer))
    (restore-timer-repeats timer repeat)

    (format t "Scheduling for the 3rd time~%")
    (is eql t (tw:schedule-timer wheel1 timer delay))
    (is eql wheel1 (tw::scheduler timer))
    (is eql 10 (tw::repeats timer))

    (sleep (+ 1 (/ (* 2 (tw::wheel-resolution wheel1)) 1000)))
    (is = 30 (tw::result timer))
    (format t "timer: ~d~%" timer)
    ))

(define-test schedule-timer-simply :parent timer-wheel
  (let* ((wheel (make-wheel))
         (timer1 (make-timer :callback (make-callback)))
         (timer2 (make-timer :callback (make-callback) :scheduler wheel)))
    (false (schedule-timer-simply timer1))
    (true  (schedule-timer-simply timer2))
    (finish (attach-scheduler timer1 wheel))
    (true  (schedule-timer-simply timer1))))

(define-test with-timer-wheel :parent timer-wheel
  (let* ((wheel (make-wheel)))
    (is = 6 (with-timer-wheel wheel (+ 1 2 3)))
    (is = 6 (with-timer-wheel (make-wheel) (+ 1 2 3)))))

(define-test with-timeout :parent timer-wheel
  (let* ((wheel (make-wheel)))
    (finish (with-timeout (wheel 1) (format t "Test with-timeout!~%")))
    (finish (with-timeout (wheel 1 schedul tim)
              (format t "Test with-timeout, scheduler: ~d, timer: ~d.~%" (tw::name schedul) (tw::name tim))))
    (finish (with-timeout ((make-wheel) 0.00001 schedul tim)
              (format t "Test with-timeout, scheduler: ~d, timer: ~d.~%" (tw::name schedul) (tw::name tim))))))
